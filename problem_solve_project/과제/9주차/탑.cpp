#include <iostream>
#include <stack>
#include <utility> // pair 자료형을 사용하기 위한 인클루드

using namespace std;

int main()
{
    int n; // 타워의 갯수

    stack<pair<int, int> > tower; // tower 의 정보. class를 사용할 수 도 있었지만 C++ STL을 공부하며, 한번 사용해보고 싶었습니다.
                                 // first : 위치정보 second : 타워의 높이 값 나타냄.

    scanf("%d", &n); // n 입력
    // 1 ~ n번째 까지 타워를 왼쪽(1번째)부터 본다고 생각하자.
    // 이 때, 왼쪽인 타워를을 아래로 두고, 오른쪽인 타워를 스택의 맨 위로 둔다고 생각하자.
    // 신호를 왼쪽으로 가니, 가장 왼쪽에 있는 것부터 본다.
    // 1. 신호를 보내면 자기 왼쪽에 있는 탑을 체크해보고 수신할 수 있는지 본다.
    // 수신할 수 있다면, top의 위치를 출력하고 다음 위치로 간다.
    for (int i = 1; i < n + 1; i++)
    {
        int h; // 각 타워의 높이
        cin >> h;
        //타워가 비워져있지 않다면
        while (!tower.empty())
        {
            // tower의 top이 h보다 크면 수신 가능이므로
            if (tower.top().second > h)
            {
                // top 의 위치를 출력하고 반복문 탈출
                printf("%d ", tower.top().first);
                break;
            }
            //그렇지 않으면 제거. 타워가 나보다 작으면 필요가 없으므로 제거한다.
            tower.pop();
        }
        //스택이 비워져 있으면 0 출력.
        if (tower.empty())
            printf("0 ");
        //모든 과정 후에 추가하여 준다.
        tower.push(make_pair(i, h));
    }
    /*
        위 과정을 예제로 살펴보자. 먼저 6 9 5 7 4 가 있다. 이는 pair 로 각 위치 정보(인덱스 정보)와 함께 스택에 저장된다.
        먼저 6을 보자. 6의 왼쪽엔 아무것도 없으므로 0 출력. 그리고 스택에 넣는다. 현재 스택 : bottom [6 ]
        그리고 그 다음 9를 보자. 9의 왼쪽엔 6이 있으나 신호를 받을 수 없다. 6 < 9 따라서, 스택에서 제거한다.
        스택에서 제거하는 이유는 어차피 9 오른쪽에 있는 탑들은 9가 있어 6을 만날수가 없다. 따라서, 스택에서 제거할 수 있다.
        그러므로 0을 출력하고 9를 스택에 push 한다. 현재 스택 : bottom [9 ]
        다음은 5 이다. 5는 자기 왼쪽에 있는 9를 만나야한다. 따라서 스택을 보면 top 값이 9이다. 그러므로 9의 위치정보를 출력하고
        자신도 스택에 들어간다. 현재 스택 : bottom [9 5 ]
        다음은 7 이다. 7은 top이 5이므로 5를 제거하고, 그 이후 9를 만나 9의 위치정보를 출력하고 자신도 스택에 들어감. 현재 스택 : bottom[9 7]
        마지막 4이다. top이 당연히 4보다 크므로 7의 위치정보를 출력하고 4를 스택에 넣는다.
        그 후 프로그램이 종료된다.
    */

    return 0;
}