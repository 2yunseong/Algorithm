#include <iostream>
#include <ctime>

using namespace std;
// 유클리드 알고리즘을 통해 재귀적으로 최대 공약수를 구한다.
// a > b 여야 한다.
int gcd(int a, int b)
{
    if (b == 0)
    { // b가 0이면, a가 최대 공약수인다.
        return a;
    }
    else
    {
        return gcd(b, a % b); // 유클리드 알고리즘을 통해 재귀적으로 호출.
    }
}
int main()
{
    long long w, h;
    cin >> w >> h;
    int g;                   // w, h 의 최대공약수
    clock_t start = clock(); // 실행시간 측정
    /*
        해당 그림을 보면, 잘려지는 사각형에 일정한 패턴이 반복됨을 볼 수 있다.
        이는 모든 사각형에 대해 마찬가지이다.
        그럼 어떤 식으로 패턴이 만들어 지는걸까? 보면 잘라지는 직선이 지나는 꼭짓점이
        나올 때 마다 패턴이 생성된다.
        그럼 이 패턴이 시사하는 바가 무엇인지 찾아야 한다. 그러기 위해 길이가 n인
        정사각형을 잘라보면, 패턴의 갯수가 n임을 알 수 있다.
        문제에서 준 그림을 좌표계로 옮겨보면, 직선이 y = (3/2)x 임을 알 수 있다.
        이는 x=2의 배수 일때 꼭짓점을 지남을 알수가 있다.
        y는 그러면 3의 배수일 때 꼭짓점을 지난다. 이는 자명하다.
        그러므로 패턴은 8과 12의 최대공약수 만큼 생성됨을 알 수가 있다.
        일단 그러니 최대공약수를 구해보자.
    */
    // gcd에는 a > b인 값이 각각 순서대로 전달 되어야 한다.
    if (w > h)
    {
        g = gcd(w, h);
    }
    else
    {
        g = gcd(h, w);
    }
    // 최대공약수가 1일 때는, 직선이 지나는 꼭짓점이 없는 것을 알 수 있다.
    // 가로 세로를 개별적으로 생각해보자.
    // 가로의 갯수와 세로의 갯수 만큼 잘리는 것을 볼 수 있다. 근데, 시작 사각형은 똑같으므로 1개를 빼주어야한다.
    // 따라서 최종적으로 잘리는 사각형의 갯수는 w + h - 1개이다.
    if (g == 1)
    {
        cout << (w * h) - (w + h - 1) << '\n';
    }
    /*
        최대 공약수가 1보다 클 때는, 패턴이 있을 때 이다.
        그 패턴을 살펴보면, 가로가 w//g , 세로가 h//g 임도 알 수 있다.
        해당 식으로 값을 구해보면, 잘리는 사각형의 갯수는
        ((w//g) + (h//g) - 1)*g 이다.
        이식을 좀 정리해보면 아래의 식을 얻을 수 있다.
        (w + h -1)*g
    */
    else if (g > 1)
    {
        cout << w * h - (w + h - g) << '\n'; // 전체 사각형 - 잘라지는 사각형
    }
    clock_t end = clock();
    printf("실행시간: %lf초\n", (double)(end - start) / CLOCKS_PER_SEC); // 소요 시간 출력
    return 0;
}